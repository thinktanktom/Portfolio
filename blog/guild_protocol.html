<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Decentralized Freelancing Platform with Chainlink Automation | Guild Protocol</title>
    <meta name="description" content="Complete guide to building a blockchain-based freelancing platform using Solidity smart contracts, Chainlink Automation, and tokenomics. Learn how to create escrow systems, dispute resolution, and automated payments.">
    <meta name="keywords" content="Chainlink automation, decentralized freelancing, blockchain escrow, smart contract freelancing, DeFi platform, Solidity tutorial, Web3 marketplace">
    <meta name="author" content="Thomas Cyriac">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.8;
            color: #2d3748;
            background: #f7fafc;
        }

        .blog-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 100px 20px 60px;
            text-align: center;
        }

        .blog-header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 20px;
            line-height: 1.2;
        }

        .blog-meta {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 0.95rem;
            opacity: 0.9;
        }

        .blog-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 60px 20px;
            background: white;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.1);
        }

        .toc {
            background: #edf2f7;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 40px;
            border-left: 4px solid #667eea;
        }

        .toc h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #2d3748;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 10px 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        h2 {
            font-size: 2rem;
            font-weight: 700;
            margin: 50px 0 25px;
            color: #2d3748;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 35px 0 20px;
            color: #4a5568;
        }

        h4 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 25px 0 15px;
            color: #718096;
        }

        p {
            margin: 20px 0;
            font-size: 1.05rem;
            line-height: 1.8;
        }

        .highlight-box {
            background: #fff5e6;
            border-left: 4px solid #f6ad55;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff0f0;
            border-left: 4px solid #fc8181;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }

        .info-box {
            background: #e6f7ff;
            border-left: 4px solid #4299e1;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #e6ffed;
            border-left: 4px solid #48bb78;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }

        code {
            background: #2d3748;
            color: #68d391;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 25px 0;
            line-height: 1.6;
        }

        pre code {
            background: none;
            padding: 0;
            color: #68d391;
        }

        ul, ol {
            margin: 20px 0 20px 30px;
        }

        li {
            margin: 12px 0;
            line-height: 1.8;
        }

        .architecture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .architecture-card {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        .architecture-card h4 {
            margin-top: 0;
            color: #667eea;
        }

        .contract-address {
            background: #2d3748;
            color: #68d391;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Monaco', monospace;
            font-size: 0.85rem;
            word-break: break-all;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }

        .feature-item {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .comparison-table tr:hover {
            background: #f7fafc;
        }

        .flow-diagram {
            background: #f7fafc;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }

        .flow-step {
            display: inline-block;
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-weight: 600;
        }

        .flow-arrow {
            display: inline-block;
            font-size: 2rem;
            color: #667eea;
            margin: 0 10px;
        }

        .author-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-top: 60px;
            text-align: center;
        }

        .author-box h3 {
            color: white;
            margin-top: 0;
        }

        .author-box a {
            color: white;
            text-decoration: underline;
        }

        .github-link {
            display: inline-block;
            background: white;
            color: #667eea;
            padding: 12px 25px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 20px;
            transition: transform 0.3s ease;
        }

        .github-link:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .blog-header h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.6rem;
            }

            .blog-meta {
                flex-direction: column;
                gap: 10px;
            }

            .comparison-table {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <header class="blog-header">
        <h1>Building a Decentralized Freelancing Platform with Chainlink Automation</h1>
        <div class="blog-meta">
            <span>ğŸ“… By Thomas Cyriac</span>
            <span>â±ï¸ 18 min read</span>
            <span>ğŸ”— Smart Contracts</span>
        </div>
    </header>

    <article class="blog-container">
        <div class="toc">
            <h2>ğŸ“‹ Table of Contents</h2>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#problem">The Problem with Traditional Freelancing</a></li>
                <li><a href="#solution">Guild Protocol: The Decentralized Solution</a></li>
                <li><a href="#architecture">System Architecture</a></li>
                <li><a href="#tokenomics">Tokenomics & Incentive Design</a></li>
                <li><a href="#chainlink">Chainlink Automation Integration</a></li>
                <li><a href="#smart-contracts">Smart Contract Implementation</a></li>
                <li><a href="#dispute-resolution">Dispute Resolution & Governance</a></li>
                <li><a href="#security">Security Considerations</a></li>
                <li><a href="#deployment">Deployed Contracts</a></li>
                <li><a href="#future">Future Enhancements</a></li>
                <li><a href="#conclusion">Conclusion</a></li>
            </ul>
        </div>

        <section id="introduction">
            <h2>Introduction</h2>
            <p>
                Freelancing platforms like Upwork, Fiverr, and Freelancer.com have revolutionized how professionals find work globally. However, these centralized platforms come with significant drawbacks: high fees (up to 20%), payment delays, arbitrary account suspensions, and lack of transparency in dispute resolution.
            </p>
            <p>
                In this comprehensive guide, I'll walk you through building <strong>Guild Protocol</strong> â€” a fully decentralized freelancing platform built on Ethereum that eliminates intermediary fees while maintaining trust through smart contracts, tokenomics, and Chainlink Automation.
            </p>

            <div class="success-box">
                <strong>ğŸ¯ What You'll Learn:</strong>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>Designing tokenomics for a marketplace</li>
                    <li>Implementing escrow systems with Solidity</li>
                    <li>Integrating Chainlink Automation for time-based payments</li>
                    <li>Building decentralized dispute resolution</li>
                    <li>Creating proof-of-stake validator selection</li>
                    <li>Security best practices for financial smart contracts</li>
                </ul>
            </div>
        </section>

        <section id="problem">
            <h2>The Problem with Traditional Freelancing Platforms</h2>
            
            <h3>Centralization Issues</h3>
            <p>
                Current freelancing platforms suffer from several critical problems:
            </p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Issue</th>
                        <th>Impact</th>
                        <th>Frequency</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>High Fees</strong></td>
                        <td>20% commission on earnings</td>
                        <td>Every transaction</td>
                    </tr>
                    <tr>
                        <td><strong>Payment Delays</strong></td>
                        <td>7-14 days to withdraw funds</td>
                        <td>Every payout</td>
                    </tr>
                    <tr>
                        <td><strong>Arbitrary Suspensions</strong></td>
                        <td>Account locked without warning</td>
                        <td>Thousands annually</td>
                    </tr>
                    <tr>
                        <td><strong>Opaque Disputes</strong></td>
                        <td>No transparency in resolution</td>
                        <td>Common</td>
                    </tr>
                    <tr>
                        <td><strong>Geographic Restrictions</strong></td>
                        <td>Limited payment methods</td>
                        <td>Varies by country</td>
                    </tr>
                </tbody>
            </table>

            <h3>Why Blockchain?</h3>
            <p>
                Blockchain technology offers elegant solutions to these problems:
            </p>
            <ul>
                <li><strong>Transparency:</strong> All transactions are verifiable on-chain</li>
                <li><strong>Lower Fees:</strong> No middleman taking 20% cuts</li>
                <li><strong>Instant Payments:</strong> Smart contracts release funds immediately</li>
                <li><strong>Censorship Resistance:</strong> No central authority can freeze accounts</li>
                <li><strong>Global Access:</strong> Anyone with a wallet can participate</li>
                <li><strong>Programmable Trust:</strong> Code enforces agreements, not corporations</li>
            </ul>

            <div class="highlight-box">
                <strong>ğŸ’¡ Real-World Context:</strong> As someone who's earned over $100K on Upwork, I've personally experienced these pain points. The 20% fee on my first jobs was particularly frustrating, and I've seen talented developers locked out of platforms with no recourse. This project was born from wanting a better system.
            </div>
        </section>

        <section id="solution">
            <h2>Guild Protocol: The Decentralized Solution</h2>
            
            <h3>Core Concept</h3>
            <p>
                Guild Protocol is a blockchain-based freelancing platform that uses smart contracts to create trustless agreements between clients and freelancers. It eliminates platform fees while maintaining quality through a token-based incentive system.
            </p>

            <h3>Key Features</h3>
            <div class="feature-grid">
                <div class="feature-item">ğŸ“ On-chain Proposals</div>
                <div class="feature-item">ğŸ’° Escrow System</div>
                <div class="feature-item">â° Automated Payments</div>
                <div class="feature-item">âš–ï¸ Dispute Resolution</div>
                <div class="feature-item">ğŸ¯ Validator Staking</div>
                <div class="feature-item">ğŸ”’ Blacklist Protection</div>
            </div>

            <h3>How It Works</h3>
            <div class="flow-diagram">
                <div class="flow-step">Client Creates Proposal</div>
                <span class="flow-arrow">â†’</span>
                <div class="flow-step">Freelancers Bid</div>
                <span class="flow-arrow">â†’</span>
                <div class="flow-step">Selection & Escrow</div>
                <span class="flow-arrow">â†’</span>
                <div class="flow-step">Work Completion</div>
                <span class="flow-arrow">â†’</span>
                <div class="flow-step">Payment Release</div>
            </div>

            <p style="text-align: center; margin-top: 20px;">
                <em>Simple 5-step process with complete transparency</em>
            </p>
        </section>

        <section id="architecture">
            <h2>System Architecture</h2>
            
            <h3>Three-Contract Design</h3>
            <p>
                Guild Protocol uses a modular architecture with three main smart contracts:
            </p>

            <div class="architecture-grid">
                <div class="architecture-card">
                    <h4>1. GuildToken Contract</h4>
                    <p>ERC-20 token (GT) that powers the entire ecosystem. Used for payments, staking, and validator rewards.</p>
                </div>
                <div class="architecture-card">
                    <h4>2. ValidatorSelection Contract</h4>
                    <p>Implements Proof-of-Stake consensus for selecting third-party validators who oversee proposals.</p>
                </div>
                <div class="architecture-card">
                    <h4>3. Client Interface Contract</h4>
                    <p>Main business logic handling proposals, bids, escrow, payments, and dispute resolution.</p>
                </div>
            </div>

            <h3>Contract Interaction Flow</h3>
            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GuildToken     â”‚
â”‚  (ERC-20)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Token Operations
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Client Interface Contract           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Proposal Management             â”‚  â”‚
â”‚  â”‚  Escrow System                   â”‚  â”‚
â”‚  â”‚  Payment Distribution            â”‚  â”‚
â”‚  â”‚  Dispute Handling                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Validator Selection
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validator       â”‚â—„â”€â”€â”€â”€â”€â”€â”¤  Chainlink   â”‚
â”‚ Selection       â”‚       â”‚  Automation  â”‚
â”‚ (PoS)           â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

            <div class="info-box">
                <strong>ğŸ—ï¸ Design Principle:</strong> Separating concerns into three contracts improves modularity, upgradability, and gas efficiency. Each contract has a single, well-defined responsibility.
            </div>
        </section>

        <section id="tokenomics">
            <h2>Tokenomics & Incentive Design</h2>
            
            <h3>Guild Token (GT) Economics</h3>
            <p>
                The Guild Token serves multiple purposes in the ecosystem:
            </p>

            <h4>1. Payment Currency</h4>
            <p>
                All bounties are denominated in GT tokens. This creates demand for the token and ensures all participants have skin in the game.
            </p>

            <h4>2. Staking Mechanism</h4>
            <p>
                Freelancers must stake 10% of the bounty amount when accepting a proposal:
            </p>
            <pre><code>// Freelancer stakes 10% of bounty
uint256 stakeAmount = (bountyAmount * 10) / 100;

// Transfer stake to escrow
guildToken.transferFrom(freelancer, address(this), stakeAmount);</code></pre>

            <div class="highlight-box">
                <strong>âš–ï¸ Why Staking?</strong> This economic mechanism ensures freelancers are incentivized to complete work. If they abandon the project, they lose their stake. If they complete successfully, they get 5% back plus the full bounty.
            </div>

            <h4>3. Validator Rewards</h4>
            <p>
                Third-party validators are compensated from multiple sources:
            </p>
            <ul>
                <li><strong>Vetting Fee:</strong> 2.5% of bounty paid by client for validator selection</li>
                <li><strong>Completion Fee:</strong> 5% of freelancer's stake upon successful completion</li>
                <li><strong>Dispute Resolution:</strong> Full 10% stake if they resolve a dispute</li>
            </ul>

            <h3>Incentive Alignment</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Participant</th>
                        <th>Incentive</th>
                        <th>Penalty</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Client</strong></td>
                        <td>Quality work, low fees</td>
                        <td>Bad reputation if unfair</td>
                    </tr>
                    <tr>
                        <td><strong>Freelancer</strong></td>
                        <td>Full payment + stake return</td>
                        <td>Lose 10% stake if abandoned</td>
                    </tr>
                    <tr>
                        <td><strong>Validator</strong></td>
                        <td>7.5% of bounty in rewards</td>
                        <td>Blacklisted if unfair</td>
                    </tr>
                </tbody>
            </table>

            <div class="warning-box">
                <strong>âš ï¸ Game Theory:</strong> The system is designed so that honest behavior is always more profitable than cheating. This is achieved through staking, reputation systems, and distributed validation.
            </div>
        </section>

        <section id="chainlink">
            <h2>Chainlink Automation Integration</h2>
            
            <h3>Why Chainlink Automation?</h3>
            <p>
                For hourly contracts, clients need to fund their proposals weekly. Smart contracts can't execute themselves, so we need an external trigger. Chainlink Automation provides decentralized, reliable time-based execution.
            </p>

            <h3>How It Works</h3>
            <p>
                Chainlink Keepers check the contract at regular intervals:
            </p>
            <pre><code>// Chainlink calls this function to check if upkeep is needed
function checkUpkeep(bytes calldata checkData)
    external
    view
    returns (bool upkeepNeeded, bytes memory performData)
{
    // Check if 1 week has passed since last payment
    upkeepNeeded = (block.timestamp >= lastPaymentTime + 1 weeks);
    performData = checkData;
}

// If upkeepNeeded is true, Chainlink calls this function
function performUpkeep(bytes calldata performData) external {
    require(msg.sender == chainlinkAutomation, "Only Chainlink");
    
    // Release weekly payment to freelancer
    uint256 weeklyAmount = calculateWeeklyPayment();
    guildToken.transfer(freelancer, weeklyAmount);
    
    lastPaymentTime = block.timestamp;
}</code></pre>

            <div class="info-box">
                <strong>ğŸ”— Chainlink Automation Link:</strong> View the live automation job on Sepolia testnet:
                <div class="contract-address" style="margin-top: 10px;">
                    <a href="https://automation.chain.link/sepolia/89582693822325869782582331309543088720413532222262009077480880623477895835351" target="_blank" style="color: #68d391;">
                        Automation Job #89582693822325869782582331309543088720413532222262009077480880623477895835351
                    </a>
                </div>
            </div>

            <h3>Benefits of Chainlink Integration</h3>
            <ul>
                <li><strong>Decentralized:</strong> No single point of failure</li>
                <li><strong>Reliable:</strong> Chainlink's proven oracle network</li>
                <li><strong>Gas Efficient:</strong> Only executes when needed</li>
                <li><strong>Transparent:</strong> All executions are on-chain</li>
            </ul>
        </section>

        <section id="smart-contracts">
            <h2>Smart Contract Implementation</h2>
            
            <h3>Core Functions</h3>
            
            <h4>1. Creating a Proposal</h4>
            <pre><code>function createProposal(
    string memory description,
    uint256 bountyAmount,
    bool isHourly,
    bool useThirdParty
) external {
    require(bountyAmount > 0, "Invalid bounty");
    
    // Transfer bounty to escrow
    guildToken.transferFrom(msg.sender, address(this), bountyAmount);
    
    // If using third party, select validator via PoS
    address validator = address(0);
    if (useThirdParty) {
        validator = validatorSelection.selectValidator();
        
        // Client pays 2.5% vetting fee
        uint256 vettingFee = (bountyAmount * 25) / 1000;
        guildToken.transferFrom(msg.sender, validator, vettingFee);
    }
    
    // Create proposal
    proposals[proposalCount] = Proposal({
        client: msg.sender,
        description: description,
        bountyAmount: bountyAmount,
        isHourly: isHourly,
        validator: validator,
        freelancer: address(0),
        status: ProposalStatus.Open
    });
    
    emit ProposalCreated(proposalCount, msg.sender, bountyAmount);
    proposalCount++;
}</code></pre>

            <h4>2. Freelancer Bidding</h4>
            <pre><code>function bidOnProposal(
    uint256 proposalId,
    uint256 counterOffer,
    string memory pitch
) external {
    Proposal storage proposal = proposals[proposalId];
    require(proposal.status == ProposalStatus.Open, "Not accepting bids");
    
    // Freelancer can propose different amount
    uint256 bidAmount = counterOffer > 0 ? counterOffer : proposal.bountyAmount;
    
    // Store bid
    bids[proposalId].push(Bid({
        freelancer: msg.sender,
        amount: bidAmount,
        pitch: pitch,
        timestamp: block.timestamp
    }));
    
    emit BidSubmitted(proposalId, msg.sender, bidAmount);
}</code></pre>

            <h4>3. Accepting a Freelancer</h4>
            <pre><code>function acceptFreelancer(
    uint256 proposalId,
    address freelancer
) external {
    Proposal storage proposal = proposals[proposalId];
    require(msg.sender == proposal.client, "Only client");
    require(proposal.status == ProposalStatus.Open, "Invalid status");
    
    // Freelancer must stake 10%
    uint256 stakeAmount = (proposal.bountyAmount * 10) / 100;
    guildToken.transferFrom(freelancer, address(this), stakeAmount);
    
    // Update proposal
    proposal.freelancer = freelancer;
    proposal.status = ProposalStatus.InProgress;
    proposal.stakeAmount = stakeAmount;
    proposal.startTime = block.timestamp;
    
    emit FreelancerAccepted(proposalId, freelancer);
}</code></pre>

            <h4>4. Completing Work & Payment</h4>
            <pre><code>function completeWork(uint256 proposalId) external {
    Proposal storage proposal = proposals[proposalId];
    require(msg.sender == proposal.client, "Only client");
    require(proposal.status == ProposalStatus.InProgress, "Invalid status");
    
    // Release bounty to freelancer
    guildToken.transfer(proposal.freelancer, proposal.bountyAmount);
    
    // Return 5% of stake to freelancer
    uint256 stakeReturn = (proposal.stakeAmount * 50) / 100;
    guildToken.transfer(proposal.freelancer, stakeReturn);
    
    // Give 5% of stake to validator as reward
    uint256 validatorReward = proposal.stakeAmount - stakeReturn;
    guildToken.transfer(proposal.validator, validatorReward);
    
    proposal.status = ProposalStatus.Completed;
    
    emit WorkCompleted(proposalId);
}</code></pre>

            <div class="success-box">
                <strong>âœ… Gas Optimization:</strong> Using <code>storage</code> pointers instead of copying structs to memory saves significant gas. Always use <code>storage</code> for modifications and <code>memory</code> only for reads.
            </div>
        </section>

        <section id="dispute-resolution">
            <h2>Dispute Resolution & Governance</h2>
            
            <h3>Decentralized Dispute Handling</h3>
            <p>
                When clients and freelancers disagree, the assigned validator steps in to resolve the dispute:
            </p>

            <pre><code>function raiseDispute(
    uint256 proposalId,
    string memory reason
) external {
    Proposal storage proposal = proposals[proposalId];
    require(
        msg.sender == proposal.client || msg.sender == proposal.freelancer,
        "Not authorized"
    );
    require(proposal.validator != address(0), "No validator assigned");
    
    proposal.status = ProposalStatus.Disputed;
    disputes[proposalId] = Dispute({
        reason: reason,
        timestamp: block.timestamp,
        resolved: false
    });
    
    emit DisputeRaised(proposalId, msg.sender, reason);
}

function resolveDispute(
    uint256 proposalId,
    bool favorClient,
    string memory resolution
) external {
    Proposal storage proposal = proposals[proposalId];
    require(msg.sender == proposal.validator, "Only validator");
    require(proposal.status == ProposalStatus.Disputed, "Not disputed");
    
    if (favorClient) {
        // Return bounty to client
        guildToken.transfer(proposal.client, proposal.bountyAmount);
        // Validator gets full 10% stake
        guildToken.transfer(proposal.validator, proposal.stakeAmount);
    } else {