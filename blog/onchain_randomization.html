<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Provably Fair NFT Distribution: My Onchain Randomization Project | Thomas Cyriac</title>
    <meta name="description" content="How I reverse-engineered and improved Hashmasks' randomization algorithm to build provably fair NFT distribution systems. Real-world smart contract development with Solidity, security considerations, and production deployment insights.">
    <meta name="keywords" content="onchain randomization, NFT smart contracts, Hashmasks, provably fair blockchain, Solidity development, NFT distribution, smart contract security, ERC-721, blockchain randomness">
    <meta name="author" content="Thomas Cyriac">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.8;
            color: #2d3748;
            background: #f7fafc;
        }

        .blog-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 120px 20px 80px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .blog-header::before {
            content: 'üé≤';
            position: absolute;
            font-size: 15rem;
            opacity: 0.1;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .blog-header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 20px;
            line-height: 1.2;
            position: relative;
            z-index: 1;
        }

        .blog-subtitle {
            font-size: 1.3rem;
            margin-bottom: 30px;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .blog-meta {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 0.95rem;
            opacity: 0.9;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .blog-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
            background: white;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.1);
        }

        .intro-box {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 35px;
            border-radius: 15px;
            margin-bottom: 50px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .intro-box h2 {
            color: white;
            border: none;
            margin: 0 0 20px 0;
            padding: 0;
            font-size: 1.8rem;
        }

        .toc {
            background: #edf2f7;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 50px;
            border-left: 5px solid #667eea;
        }

        .toc h2 {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #2d3748;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 12px 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .toc a:hover {
            text-decoration: underline;
            padding-left: 10px;
        }

        h2 {
            font-size: 2.2rem;
            font-weight: 700;
            margin: 60px 0 30px;
            color: #2d3748;
            border-bottom: 4px solid #667eea;
            padding-bottom: 12px;
        }

        h3 {
            font-size: 1.6rem;
            font-weight: 600;
            margin: 40px 0 20px;
            color: #4a5568;
        }

        h4 {
            font-size: 1.3rem;
            font-weight: 600;
            margin: 30px 0 15px;
            color: #718096;
        }

        p {
            margin: 20px 0;
            font-size: 1.1rem;
            line-height: 1.9;
        }

        .highlight-box {
            background: #fff5e6;
            border-left: 5px solid #f6ad55;
            padding: 25px;
            margin: 35px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .info-box {
            background: #e6f7ff;
            border-left: 5px solid #4299e1;
            padding: 25px;
            margin: 35px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .success-box {
            background: #e6ffed;
            border-left: 5px solid #48bb78;
            padding: 25px;
            margin: 35px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .warning-box {
            background: #fff0f0;
            border-left: 5px solid #fc8181;
            padding: 25px;
            margin: 35px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        code {
            background: #2d3748;
            color: #68d391;
            padding: 4px 10px;
            border-radius: 5px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.92em;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 25px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 30px 0;
            line-height: 1.7;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        pre code {
            background: none;
            padding: 0;
            color: #68d391;
        }

        ul, ol {
            margin: 25px 0 25px 35px;
        }

        li {
            margin: 15px 0;
            line-height: 1.9;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 35px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 18px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 18px;
            border-bottom: 1px solid #e2e8f0;
        }

        .comparison-table tr:hover {
            background: #f7fafc;
        }

        .author-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 80px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3);
        }

        .author-box h3 {
            color: white;
            margin-top: 0;
            font-size: 2rem;
        }

        .author-box a {
            color: white;
            text-decoration: underline;
        }

        .cta-button {
            display: inline-block;
            background: white;
            color: #667eea;
            padding: 15px 30px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            margin: 10px;
        }

        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .blog-header h1 {
                font-size: 2rem;
            }

            .blog-subtitle {
                font-size: 1.1rem;
            }

            h2 {
                font-size: 1.8rem;
            }

            .blog-meta {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <header class="blog-header">
        <h1>Building Provably Fair NFT Distribution: The Onchain Randomization Challenge</h1>
        <p class="blog-subtitle">How I Reverse-Engineered Hashmasks and Built a Production-Ready Randomization System</p>
        <div class="blog-meta">
            <span>üìÖ By Thomas Cyriac</span>
            <span>‚è±Ô∏è 12 min read</span>
            <span>üéØ Smart Contract Development</span>
        </div>
    </header>

    <article class="blog-container">
        <div class="intro-box">
            <h2>The Challenge</h2>
            <p>
                A client approached me with a common but critical problem: they needed to launch an NFT collection where rarity distribution had to be <strong>provably fair</strong>. No manipulation, no insider advantage, completely transparent. They'd seen how Hashmasks did it with their $16 million successful launch, but the implementation details weren't publicly documented.
            </p>
            <p style="margin-top: 15px;">
                <strong>My task:</strong> Reverse-engineer the Hashmasks randomization algorithm, understand why it works, and build a reusable implementation that could be deployed to production.
            </p>
        </div>

        <div class="toc">
            <h2>üìã What You'll Learn</h2>
            <ul>
                <li><a href="#problem">The Blockchain Randomness Problem</a></li>
                <li><a href="#research">Reverse Engineering Hashmasks</a></li>
                <li><a href="#algorithm">Understanding the Algorithm</a></li>
                <li><a href="#implementation">My Implementation</a></li>
                <li><a href="#improvements">Improvements I Made</a></li>
                <li><a href="#security">Security Considerations</a></li>
                <li><a href="#deployment">Production Deployment</a></li>
                <li><a href="#lessons">Lessons Learned</a></li>
            </ul>
        </div>

        <section id="problem">
            <h2>The Blockchain Randomness Problem</h2>
            
            <h3>Why You Can't Just Use Random Numbers</h3>
            <p>
                When I first started working with smart contracts, I thought randomness would be straightforward. Just call some <code>random()</code> function, right? Wrong. Blockchains are deterministic by design‚Äîevery node must arrive at the same result when executing a transaction.
            </p>

            <p>
                This creates a fundamental challenge for NFT projects:
            </p>
            <ul>
                <li>If you assign rarity at mint time, people will game it by simulating transactions off-chain</li>
                <li>If you use predictable on-chain values (like <code>block.timestamp</code>), miners can manipulate them</li>
                <li>If you use off-chain randomness, there's no way to verify fairness</li>
            </ul>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Real Stakes:</strong> Get this wrong and your project loses credibility immediately. I've seen NFT projects tank because people discovered the "random" distribution was actually predictable. Trust is everything in this space.
            </div>

            <h3>Common (Bad) Approaches I've Seen</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Why It Fails</th>
                        <th>Attack Vector</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>block.timestamp</code></td>
                        <td>Miners control this value</td>
                        <td>Can delay blocks to get favorable outcomes</td>
                    </tr>
                    <tr>
                        <td><code>block.difficulty</code></td>
                        <td>Predictable and manipulatable</td>
                        <td>Known ahead of time by miners</td>
                    </tr>
                    <tr>
                        <td>Off-chain random API</td>
                        <td>Not verifiable on-chain</td>
                        <td>Trust in centralized service</td>
                    </tr>
                    <tr>
                        <td>User-provided randomness</td>
                        <td>Last mover advantage</td>
                        <td>Final user can choose outcome</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="research">
            <h2>Reverse Engineering Hashmasks</h2>
            
            <h3>Starting Point: Etherscan</h3>
            <p>
                My first step was diving into the Hashmasks contract on Etherscan. I spent hours reading through their verified source code, tracing function calls, and understanding their state management. Here's what I discovered:
            </p>

            <h4>The Key Insight</h4>
            <p>
                Hashmasks doesn't reveal NFT metadata at mint time. Instead, they use a two-phase process:
            </p>
            <ol>
                <li><strong>Blind Minting:</strong> Users mint NFTs without knowing which artwork they'll get</li>
                <li><strong>Reveal Phase:</strong> After all NFTs are minted (or a time limit is reached), a "starting index" is calculated</li>
                <li><strong>Deterministic Mapping:</strong> Each token ID maps to metadata using: <code>(tokenId + startingIndex) % totalSupply</code></li>
            </ol>

            <div class="highlight-box">
                <strong>üí° The Genius Move:</strong> The starting index is derived from a future block hash that doesn't exist during the minting period. This means <em>nobody</em>‚Äînot even the contract deployer‚Äîcan know which artwork maps to which token ID until after minting completes.
            </div>

            <h3>Analyzing the Contract</h3>
            <p>
                Here's the core logic I extracted from their contract:
            </p>
            <pre><code>// Simplified version of what I found
uint256 public startingIndexBlock;
uint256 public startingIndex;

function finalizeStartingIndex() external {
    require(startingIndex == 0, "Already set");
    require(startingIndexBlock != 0, "Block not set");
    
    // Use block hash from specific block in the future
    startingIndex = uint(blockhash(startingIndexBlock)) % MAX_SUPPLY;
    
    // Prevent all-zero scenario
    if (startingIndex == 0) {
        startingIndex = 1;
    }
}</code></pre>

            <p>
                Simple, elegant, and secure. But I found some edge cases that needed handling...
            </p>
        </section>

        <section id="algorithm">
            <h2>Understanding the Algorithm</h2>
            
            <h3>How It Actually Works</h3>
            <p>
                Let me break down the algorithm step-by-step, as I explained it to my client:
            </p>

            <h4>Phase 1: Minting (Days 1-7)</h4>
            <ol>
                <li>Users mint NFTs at random, receiving token IDs: 0, 1, 2, 3...</li>
                <li>No metadata is revealed‚Äîeveryone sees a placeholder image</li>
                <li>When the last NFT is minted, the contract records the current <code>block.number</code></li>
            </ol>

            <h4>Phase 2: Waiting Period (Minutes)</h4>
            <ol>
                <li>The contract waits for 10 additional blocks to be mined</li>
                <li>This creates a "reveal block" that's in the future during minting</li>
                <li>This block hash becomes our source of randomness</li>
            </ol>

            <h4>Phase 3: Reveal</h4>
            <ol>
                <li>Anyone calls <code>setStartingIndex()</code></li>
                <li>Contract reads the reveal block's hash</li>
                <li>Starting index = <code>blockhash(revealBlock) % MAX_SUPPLY</code></li>
                <li>Metadata is now publicly mapped: token 0 ‚Üí metadata[startingIndex], token 1 ‚Üí metadata[startingIndex + 1], etc.</li>
            </ol>

            <div class="info-box">
                <strong>üîê Security Through Timing:</strong> The reveal block hash didn't exist during minting. By the time it exists, minting is over. Nobody can choose their token ID based on the outcome because the outcome is determined <em>after</em> token IDs are assigned.
            </div>

            <h3>Why This Works</h3>
            <p>
                The brilliance is in the timing:
            </p>
            <ul>
                <li><strong>During minting:</strong> Future block hash is unknown ‚Üí unpredictable</li>
                <li><strong>After minting:</strong> Block hash is known ‚Üí verifiable by everyone</li>
                <li><strong>Miner manipulation:</strong> Too expensive (would need to control 10+ consecutive blocks)</li>
                <li><strong>Front-running:</strong> Impossible (you can't mint after the index is set)</li>
            </ul>
        </section>

        <section id="implementation">
            <h2>My Implementation</h2>
            
            <h3>Building the Contract</h3>
            <p>
                Armed with this understanding, I built my own implementation from scratch. Here's the core contract:
            </p>

            <pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract RandomizedNFT is ERC721, Ownable, ReentrancyGuard {
    using Strings for uint256;
    
    uint256 public constant MAX_SUPPLY = 10000;
    uint256 public constant REVEAL_TIMESTAMP = 0; // Set to specific time if needed
    uint256 public constant MAX_PER_TX = 20;
    
    uint256 private _tokenIdCounter;
    uint256 public startingIndexBlock;
    uint256 public startingIndex;
    
    string public baseURI;
    bool public saleIsActive = false;
    
    constructor(
        string memory name,
        string memory symbol,
        string memory _baseURI
    ) ERC721(name, symbol) {
        baseURI = _baseURI;
    }
    
    function mint(uint256 numberOfTokens) external payable nonReentrant {
        require(saleIsActive, "Sale not active");
        require(numberOfTokens > 0 && numberOfTokens <= MAX_PER_TX, "Invalid amount");
        require(_tokenIdCounter + numberOfTokens <= MAX_SUPPLY, "Exceeds max supply");
        
        for (uint256 i = 0; i < numberOfTokens; i++) {
            _safeMint(msg.sender, _tokenIdCounter);
            _tokenIdCounter++;
        }
        
        // Set starting index block when last token minted
        if (startingIndexBlock == 0 && 
            (_tokenIdCounter == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)
        ) {
            startingIndexBlock = block.number;
        }
    }
    
    function setStartingIndex() external {
        require(startingIndex == 0, "Starting index already set");
        require(startingIndexBlock != 0, "Starting index block not set");
        
        // Use block hash from 10 blocks after starting block
        uint256 targetBlock = startingIndexBlock + 10;
        bytes32 targetBlockHash = blockhash(targetBlock);
        
        // Fallback if block hash unavailable (>256 blocks ago)
        if (targetBlockHash == bytes32(0)) {
            targetBlockHash = blockhash(block.number - 1);
        }
        
        startingIndex = uint256(targetBlockHash) % MAX_SUPPLY;
        
        // Prevent zero index
        if (startingIndex == 0) {
            startingIndex = 1;
        }
    }
    
    function tokenURI(uint256 tokenId) 
        public 
        view 
        override 
        returns (string memory) 
    {
        require(_exists(tokenId), "Token doesn't exist");
        
        // Return placeholder before reveal
        if (startingIndex == 0) {
            return string(abi.encodePacked(baseURI, "unrevealed.json"));
        }
        
        // Map token ID to metadata ID using starting index
        uint256 metadataId = (tokenId + startingIndex) % MAX_SUPPLY;
        return string(abi.encodePacked(baseURI, metadataId.toString(), ".json"));
    }
    
    function flipSaleState() external onlyOwner {
        saleIsActive = !saleIsActive;
    }
    
    function setBaseURI(string memory _baseURI) external onlyOwner {
        baseURI = _baseURI;
    }
    
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }
}</code></pre>
        </section>

        <section id="improvements">
            <h2>Improvements I Made</h2>
            
            <h3>1. Fallback Mechanism</h3>
            <p>
                Ethereum only stores the most recent 256 block hashes. If <code>setStartingIndex()</code> isn't called within ~1 hour after minting completes, the target block hash becomes unavailable.
            </p>
            <p>
                My solution:
            </p>
            <pre><code>// Fallback to recent block if target unavailable
if (targetBlockHash == bytes32(0)) {
    targetBlockHash = blockhash(block.number - 1);
}</code></pre>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Security Trade-off:</strong> The fallback is slightly less secure (uses a more recent block), but it's necessary for practical deployment. In production, you'd want monitoring to ensure <code>setStartingIndex()</code> is called promptly.
            </div>

            <h3>2. Unrevealed Metadata</h3>
            <p>
                Instead of failing when <code>tokenURI</code> is called before reveal, I return a placeholder:
            </p>
            <pre><code>if (startingIndex == 0) {
    return string(abi.encodePacked(baseURI, "unrevealed.json"));
}</code></pre>

            <p>
                This provides a better user experience‚Äîmarketplaces can still display the NFT with a "mystery box" image.
            </p>

            <h3>3. Time-Based Reveal Option</h3>
            <p>
                Added support for time-based reveals in case not all NFTs sell:
            </p>
            <pre><code>if (startingIndexBlock == 0 && 
    (_tokenIdCounter == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)
) {
    startingIndexBlock = block.number;
}</code></pre>

            <h3>4. Reentrancy Protection</h3>
            <p>
                Added OpenZeppelin's ReentrancyGuard to the mint function‚Äîalways important when handling ETH transfers:
            </p>
            <pre><code>function mint(uint256 numberOfTokens) external payable nonReentrant {
    // Mint logic...
}</code></pre>
        </section>

        <section id="security">
            <h2>Security Considerations</h2>
            
            <h3>Attack Vectors I Considered</h3>

            <h4>1. Miner Manipulation</h4>
            <p>
                <strong>Risk:</strong> Could a miner manipulate block hashes to influence the starting index?
            </p>
            <p>
                <strong>Analysis:</strong> To do this, a miner would need to:
            </p>
            <ul>
                <li>Control 10 consecutive blocks (~2 minutes of network time)</li>
                <li>Sacrifice block rewards (~2 ETH per block = 20 ETH total)</li>
                <li>All for the chance to maybe get a rare NFT</li>
            </ul>
            <p>
                <strong>Conclusion:</strong> Economically unfeasible for most NFT projects. The cost exceeds any reasonable gain.
            </p>

            <h4>2. Front-Running the Reveal</h4>
            <p>
                <strong>Risk:</strong> Could someone monitor the mempool and front-run <code>setStartingIndex()</code>?
            </p>
            <p>
                <strong>Analysis:</strong> By the time <code>setStartingIndex()</code> is callable, all token IDs are already assigned. Front-running doesn't help because you can't choose your token ID after the fact.
            </p>
            <p>
                <strong>Conclusion:</strong> Not a concern.
            </p>

            <h4>3. Integer Overflow/Underflow</h4>
            <p>
                <strong>Mitigation:</strong> Using Solidity 0.8+ with built-in overflow protection. All arithmetic operations are safe by default.
            </p>

            <h4>4. Access Control</h4>
            <p>
                <strong>Implemented:</strong> Used OpenZeppelin's <code>Ownable</code> for admin functions and proper modifiers throughout.
            </p>

            <div class="success-box">
                <strong>‚úÖ Audit Preparation:</strong> I documented all security considerations and edge cases in inline comments. When the client eventually got a third-party audit, the auditors found no critical issues with the randomization logic.
            </div>
        </section>

        <section id="deployment">
            <h2>Production Deployment</h2>
            
            <h3>Testing Strategy</h3>
            <p>
                Before deploying to mainnet, I ran extensive tests:
            </p>

            <h4>1. Unit Tests</h4>
            <pre><code>// Example test with Hardhat
describe("Randomization", function () {
    it("Should set starting index after reveal block", async function () {
        // Mint all tokens
        await nft.mint(MAX_SUPPLY);
        
        // Mine 10 blocks
        for (let i = 0; i < 10; i++) {
            await ethers.provider.send("evm_mine");
        }
        
        // Set starting index
        await nft.setStartingIndex();
        
        const startingIndex = await nft.startingIndex();
        expect(startingIndex).to.be.gt(0);
        expect(startingIndex).to.be.lt(MAX_SUPPLY);
    });
});</code></pre>

            <h4>2. Testnet Deployment</h4>
            <p>
                Deployed to Rinkeby testnet and ran through complete mint/reveal cycle multiple times to verify:
            </p>
            <ul>
                <li>Gas costs were acceptable (~50k gas per mint)</li>
                <li>Starting index calculation worked correctly</li>
                <li>Metadata mapping was correct</li>
                <li>Fallback mechanism triggered appropriately</li>
            </ul>

            <h4>3. Mainnet Launch</h4>
            <p>
                For the actual launch:
            </p>
            <ul>
                <li>Set up monitoring with Tenderly for contract events</li>
                <li>Created a bot to call <code>setStartingIndex()</code> automatically after reveal block</li>
                <li>Had emergency pause functionality ready (though never needed it)</li>
            </ul>

            <div class="highlight-box">
                <strong>üí∞ Real Results:</strong> The contract handled 10,000 NFT mints smoothly. Total gas costs were under $500 even during high network congestion. The reveal happened exactly as planned, and the randomization was verified by the community within minutes.
            </div>
        </section>

        <section id="lessons">
            <h2>Lessons Learned</h2>
            
            <h3>What Worked Well</h3>
            <ul>
                <li><strong>Starting from production code:</strong> Reverse-engineering Hashmasks gave me battle-tested patterns</li>
                <li><strong>Extensive testing:</strong> Caught the block hash availability issue before mainnet</li>
                <li><strong>Clear documentation:</strong> Made auditing and client confidence much easier</li>
                <li><strong>Automated monitoring:</strong> Removed human error from critical operations</li>
            </ul>

            <h3>What I'd Do Differently</h3>
            <ul>
                <li><strong>Add Chainlink VRF option:</strong> For high-value projects, the extra security is worth the cost</li>
                <li><strong>Implement commit-reveal for metadata:</strong> Extra layer of trustlessness</li>
                <li><strong>Build a dashboard:</strong> Real-time stats during minting would have been nice</li>
            </ul>

            <h3>Skills This Project Developed</h3